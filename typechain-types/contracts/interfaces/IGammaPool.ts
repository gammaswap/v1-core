/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../common";

export declare namespace IGammaPool {
  export type FeeIndexUpdateParamsStruct = {
    shortStrategy: PromiseOrValue<string>;
    paramsStore: PromiseOrValue<string>;
    pool: PromiseOrValue<string>;
    BORROWED_INVARIANT: PromiseOrValue<BigNumberish>;
    LP_TOKEN_BALANCE: PromiseOrValue<BigNumberish>;
    lastCFMMInvariant: PromiseOrValue<BigNumberish>;
    lastCFMMTotalSupply: PromiseOrValue<BigNumberish>;
    LAST_BLOCK_NUMBER: PromiseOrValue<BigNumberish>;
    accFeeIndex: PromiseOrValue<BigNumberish>;
    lastCFMMFeeIndex: PromiseOrValue<BigNumberish>;
    emaUtilRate: PromiseOrValue<BigNumberish>;
    emaMultiplier: PromiseOrValue<BigNumberish>;
    minUtilRate1: PromiseOrValue<BigNumberish>;
    minUtilRate2: PromiseOrValue<BigNumberish>;
    feeDivisor: PromiseOrValue<BigNumberish>;
    origFee: PromiseOrValue<BigNumberish>;
    ltvThreshold: PromiseOrValue<BigNumberish>;
    liquidationFee: PromiseOrValue<BigNumberish>;
  };

  export type FeeIndexUpdateParamsStructOutput = [
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    shortStrategy: string;
    paramsStore: string;
    pool: string;
    BORROWED_INVARIANT: BigNumber;
    LP_TOKEN_BALANCE: BigNumber;
    lastCFMMInvariant: BigNumber;
    lastCFMMTotalSupply: BigNumber;
    LAST_BLOCK_NUMBER: BigNumber;
    accFeeIndex: BigNumber;
    lastCFMMFeeIndex: BigNumber;
    emaUtilRate: BigNumber;
    emaMultiplier: BigNumber;
    minUtilRate1: BigNumber;
    minUtilRate2: BigNumber;
    feeDivisor: BigNumber;
    origFee: BigNumber;
    ltvThreshold: BigNumber;
    liquidationFee: BigNumber;
  };

  export type LoanDataStruct = {
    id: PromiseOrValue<BigNumberish>;
    tokenId: PromiseOrValue<BigNumberish>;
    poolId: PromiseOrValue<string>;
    rateIndex: PromiseOrValue<BigNumberish>;
    initLiquidity: PromiseOrValue<BigNumberish>;
    lastLiquidity: PromiseOrValue<BigNumberish>;
    liquidity: PromiseOrValue<BigNumberish>;
    collateral: PromiseOrValue<BigNumberish>;
    lpTokens: PromiseOrValue<BigNumberish>;
    tokensHeld: PromiseOrValue<BigNumberish>[];
    refAddr: PromiseOrValue<string>;
    refFee: PromiseOrValue<BigNumberish>;
    refType: PromiseOrValue<BigNumberish>;
    px: PromiseOrValue<BigNumberish>;
    canLiquidate: PromiseOrValue<boolean>;
    accFeeIndex: PromiseOrValue<BigNumberish>;
    lastCFMMFeeIndex: PromiseOrValue<BigNumberish>;
    LAST_BLOCK_NUMBER: PromiseOrValue<BigNumberish>;
    tokens: PromiseOrValue<string>[];
    decimals: PromiseOrValue<BigNumberish>[];
    symbols: PromiseOrValue<string>[];
    names: PromiseOrValue<string>[];
    paramsStore: PromiseOrValue<string>;
    shortStrategy: PromiseOrValue<string>;
    BORROWED_INVARIANT: PromiseOrValue<BigNumberish>;
    LP_TOKEN_BALANCE: PromiseOrValue<BigNumberish>;
    lastCFMMInvariant: PromiseOrValue<BigNumberish>;
    lastCFMMTotalSupply: PromiseOrValue<BigNumberish>;
    ltvThreshold: PromiseOrValue<BigNumberish>;
    liquidationFee: PromiseOrValue<BigNumberish>;
  };

  export type LoanDataStructOutput = [
    BigNumber,
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber[],
    string,
    number,
    number,
    BigNumber,
    boolean,
    BigNumber,
    BigNumber,
    BigNumber,
    string[],
    number[],
    string[],
    string[],
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    id: BigNumber;
    tokenId: BigNumber;
    poolId: string;
    rateIndex: BigNumber;
    initLiquidity: BigNumber;
    lastLiquidity: BigNumber;
    liquidity: BigNumber;
    collateral: BigNumber;
    lpTokens: BigNumber;
    tokensHeld: BigNumber[];
    refAddr: string;
    refFee: number;
    refType: number;
    px: BigNumber;
    canLiquidate: boolean;
    accFeeIndex: BigNumber;
    lastCFMMFeeIndex: BigNumber;
    LAST_BLOCK_NUMBER: BigNumber;
    tokens: string[];
    decimals: number[];
    symbols: string[];
    names: string[];
    paramsStore: string;
    shortStrategy: string;
    BORROWED_INVARIANT: BigNumber;
    LP_TOKEN_BALANCE: BigNumber;
    lastCFMMInvariant: BigNumber;
    lastCFMMTotalSupply: BigNumber;
    ltvThreshold: BigNumber;
    liquidationFee: BigNumber;
  };

  export type PoolDataStruct = {
    poolId: PromiseOrValue<string>;
    protocolId: PromiseOrValue<BigNumberish>;
    borrowStrategy: PromiseOrValue<string>;
    repayStrategy: PromiseOrValue<string>;
    rebalanceStrategy: PromiseOrValue<string>;
    shortStrategy: PromiseOrValue<string>;
    singleLiquidationStrategy: PromiseOrValue<string>;
    batchLiquidationStrategy: PromiseOrValue<string>;
    factory: PromiseOrValue<string>;
    paramsStore: PromiseOrValue<string>;
    LP_TOKEN_BALANCE: PromiseOrValue<BigNumberish>;
    LP_TOKEN_BORROWED: PromiseOrValue<BigNumberish>;
    LP_TOKEN_BORROWED_PLUS_INTEREST: PromiseOrValue<BigNumberish>;
    BORROWED_INVARIANT: PromiseOrValue<BigNumberish>;
    LP_INVARIANT: PromiseOrValue<BigNumberish>;
    cfmm: PromiseOrValue<string>;
    accFeeIndex: PromiseOrValue<BigNumberish>;
    extSwapFee: PromiseOrValue<BigNumberish>;
    origFee: PromiseOrValue<BigNumberish>;
    LAST_BLOCK_NUMBER: PromiseOrValue<BigNumberish>;
    lastCFMMFeeIndex: PromiseOrValue<BigNumberish>;
    lastCFMMInvariant: PromiseOrValue<BigNumberish>;
    lastCFMMTotalSupply: PromiseOrValue<BigNumberish>;
    totalSupply: PromiseOrValue<BigNumberish>;
    tokens: PromiseOrValue<string>[];
    symbols: PromiseOrValue<string>[];
    names: PromiseOrValue<string>[];
    decimals: PromiseOrValue<BigNumberish>[];
    TOKEN_BALANCE: PromiseOrValue<BigNumberish>[];
    CFMM_RESERVES: PromiseOrValue<BigNumberish>[];
    lastPrice: PromiseOrValue<BigNumberish>;
    lastFeeIndex: PromiseOrValue<BigNumberish>;
    borrowRate: PromiseOrValue<BigNumberish>;
    utilizationRate: PromiseOrValue<BigNumberish>;
    currBlockNumber: PromiseOrValue<BigNumberish>;
    ltvThreshold: PromiseOrValue<BigNumberish>;
    liquidationFee: PromiseOrValue<BigNumberish>;
    supplyRate: PromiseOrValue<BigNumberish>;
    emaUtilRate: PromiseOrValue<BigNumberish>;
    emaMultiplier: PromiseOrValue<BigNumberish>;
    minUtilRate1: PromiseOrValue<BigNumberish>;
    minUtilRate2: PromiseOrValue<BigNumberish>;
    feeDivisor: PromiseOrValue<BigNumberish>;
  };

  export type PoolDataStructOutput = [
    string,
    number,
    string,
    string,
    string,
    string,
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    BigNumber,
    number,
    number,
    number,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    string[],
    string[],
    string[],
    number[],
    BigNumber[],
    BigNumber[],
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    number,
    number,
    number,
    BigNumber,
    number,
    number,
    number,
    number,
    number
  ] & {
    poolId: string;
    protocolId: number;
    borrowStrategy: string;
    repayStrategy: string;
    rebalanceStrategy: string;
    shortStrategy: string;
    singleLiquidationStrategy: string;
    batchLiquidationStrategy: string;
    factory: string;
    paramsStore: string;
    LP_TOKEN_BALANCE: BigNumber;
    LP_TOKEN_BORROWED: BigNumber;
    LP_TOKEN_BORROWED_PLUS_INTEREST: BigNumber;
    BORROWED_INVARIANT: BigNumber;
    LP_INVARIANT: BigNumber;
    cfmm: string;
    accFeeIndex: BigNumber;
    extSwapFee: number;
    origFee: number;
    LAST_BLOCK_NUMBER: number;
    lastCFMMFeeIndex: BigNumber;
    lastCFMMInvariant: BigNumber;
    lastCFMMTotalSupply: BigNumber;
    totalSupply: BigNumber;
    tokens: string[];
    symbols: string[];
    names: string[];
    decimals: number[];
    TOKEN_BALANCE: BigNumber[];
    CFMM_RESERVES: BigNumber[];
    lastPrice: BigNumber;
    lastFeeIndex: BigNumber;
    borrowRate: BigNumber;
    utilizationRate: BigNumber;
    currBlockNumber: number;
    ltvThreshold: number;
    liquidationFee: number;
    supplyRate: BigNumber;
    emaUtilRate: number;
    emaMultiplier: number;
    minUtilRate1: number;
    minUtilRate2: number;
    feeDivisor: number;
  };
}

export interface IGammaPoolInterface extends utils.Interface {
  functions: {
    "batchLiquidationStrategy()": FunctionFragment;
    "batchLiquidations(uint256[])": FunctionFragment;
    "borrowLiquidity(uint256,uint256,uint256[])": FunctionFragment;
    "borrowStrategy()": FunctionFragment;
    "calcInvariant(uint128[])": FunctionFragment;
    "cfmm()": FunctionFragment;
    "createLoan(uint16)": FunctionFragment;
    "decreaseCollateral(uint256,uint128[],address,uint256[])": FunctionFragment;
    "depositNoPull(address)": FunctionFragment;
    "depositReserves(address,uint256[],uint256[],bytes)": FunctionFragment;
    "factory()": FunctionFragment;
    "getCFMMBalances()": FunctionFragment;
    "getFeeIndexUpdateParams()": FunctionFragment;
    "getLastCFMMPrice()": FunctionFragment;
    "getLatestCFMMBalances()": FunctionFragment;
    "getLatestCFMMReserves()": FunctionFragment;
    "getLoanCount()": FunctionFragment;
    "getLoanData(uint256)": FunctionFragment;
    "getLoans(uint256,uint256,bool)": FunctionFragment;
    "getLoansById(uint256[],bool)": FunctionFragment;
    "getPoolBalances()": FunctionFragment;
    "getPoolData()": FunctionFragment;
    "getRates()": FunctionFragment;
    "increaseCollateral(uint256,uint256[])": FunctionFragment;
    "initialize(address,address[],uint8[],bytes)": FunctionFragment;
    "liquidate(uint256)": FunctionFragment;
    "liquidateWithLP(uint256)": FunctionFragment;
    "loan(uint256)": FunctionFragment;
    "protocolId()": FunctionFragment;
    "rateParamsStore()": FunctionFragment;
    "rebalanceCollateral(uint256,int256[],uint256[])": FunctionFragment;
    "rebalanceStrategy()": FunctionFragment;
    "repayLiquidity(uint256,uint256,uint256,address)": FunctionFragment;
    "repayLiquiditySetRatio(uint256,uint256,uint256[])": FunctionFragment;
    "repayLiquidityWithLP(uint256,uint256,address)": FunctionFragment;
    "repayStrategy()": FunctionFragment;
    "setPoolParams(uint16,uint8,uint8,uint8,uint8,uint16,uint8,uint8)": FunctionFragment;
    "shortStrategy()": FunctionFragment;
    "singleLiquidationStrategy()": FunctionFragment;
    "skim(address)": FunctionFragment;
    "sync()": FunctionFragment;
    "tokens()": FunctionFragment;
    "updatePool(uint256)": FunctionFragment;
    "validateCFMM(address[],address,bytes)": FunctionFragment;
    "validateParameters(bytes)": FunctionFragment;
    "viewer()": FunctionFragment;
    "withdrawNoPull(address)": FunctionFragment;
    "withdrawReserves(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "batchLiquidationStrategy"
      | "batchLiquidations"
      | "borrowLiquidity"
      | "borrowStrategy"
      | "calcInvariant"
      | "cfmm"
      | "createLoan"
      | "decreaseCollateral"
      | "depositNoPull"
      | "depositReserves"
      | "factory"
      | "getCFMMBalances"
      | "getFeeIndexUpdateParams"
      | "getLastCFMMPrice"
      | "getLatestCFMMBalances"
      | "getLatestCFMMReserves"
      | "getLoanCount"
      | "getLoanData"
      | "getLoans"
      | "getLoansById"
      | "getPoolBalances"
      | "getPoolData"
      | "getRates"
      | "increaseCollateral"
      | "initialize"
      | "liquidate"
      | "liquidateWithLP"
      | "loan"
      | "protocolId"
      | "rateParamsStore"
      | "rebalanceCollateral"
      | "rebalanceStrategy"
      | "repayLiquidity"
      | "repayLiquiditySetRatio"
      | "repayLiquidityWithLP"
      | "repayStrategy"
      | "setPoolParams"
      | "shortStrategy"
      | "singleLiquidationStrategy"
      | "skim"
      | "sync"
      | "tokens"
      | "updatePool"
      | "validateCFMM"
      | "validateParameters"
      | "viewer"
      | "withdrawNoPull"
      | "withdrawReserves"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "batchLiquidationStrategy",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "batchLiquidations",
    values: [PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "borrowLiquidity",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "borrowStrategy",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "calcInvariant",
    values: [PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(functionFragment: "cfmm", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "createLoan",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "decreaseCollateral",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "depositNoPull",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "depositReserves",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(functionFragment: "factory", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getCFMMBalances",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getFeeIndexUpdateParams",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getLastCFMMPrice",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getLatestCFMMBalances",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getLatestCFMMReserves",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getLoanCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getLoanData",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getLoans",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getLoansById",
    values: [PromiseOrValue<BigNumberish>[], PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "getPoolBalances",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getPoolData",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "getRates", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "increaseCollateral",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidate",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidateWithLP",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "loan",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "protocolId",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "rateParamsStore",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "rebalanceCollateral",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "rebalanceStrategy",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "repayLiquidity",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "repayLiquiditySetRatio",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "repayLiquidityWithLP",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "repayStrategy",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setPoolParams",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "shortStrategy",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "singleLiquidationStrategy",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "skim",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(functionFragment: "sync", values?: undefined): string;
  encodeFunctionData(functionFragment: "tokens", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "updatePool",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "validateCFMM",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "validateParameters",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: "viewer", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "withdrawNoPull",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawReserves",
    values: [PromiseOrValue<string>]
  ): string;

  decodeFunctionResult(
    functionFragment: "batchLiquidationStrategy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchLiquidations",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "borrowLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "borrowStrategy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calcInvariant",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "cfmm", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "createLoan", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "decreaseCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositNoPull",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "depositReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "factory", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getCFMMBalances",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFeeIndexUpdateParams",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLastCFMMPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLatestCFMMBalances",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLatestCFMMReserves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLoanCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getLoanData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getLoans", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getLoansById",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPoolBalances",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPoolData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getRates", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "increaseCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "liquidate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "liquidateWithLP",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "loan", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "protocolId", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "rateParamsStore",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rebalanceCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rebalanceStrategy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "repayLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "repayLiquiditySetRatio",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "repayLiquidityWithLP",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "repayStrategy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPoolParams",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "shortStrategy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "singleLiquidationStrategy",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "skim", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "sync", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "tokens", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "updatePool", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "validateCFMM",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "validateParameters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "viewer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawNoPull",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawReserves",
    data: BytesLike
  ): Result;

  events: {
    "Approval(address,address,uint256)": EventFragment;
    "Deposit(address,address,uint256,uint256)": EventFragment;
    "ExternalSwap(uint256,uint128[],uint256,uint128,uint8)": EventFragment;
    "Liquidation(uint256,uint128,uint128,uint128,uint128,uint8)": EventFragment;
    "LoanCreated(address,uint256,uint16)": EventFragment;
    "LoanUpdated(uint256,uint128[],uint128,uint128,uint256,uint96,uint8)": EventFragment;
    "PoolUpdated(uint256,uint256,uint40,uint80,uint256,uint128,uint128,uint128[],uint8)": EventFragment;
    "Transfer(address,address,uint256)": EventFragment;
    "Withdraw(address,address,address,uint256,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Approval"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Deposit"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExternalSwap"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Liquidation"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LoanCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LoanUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PoolUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Transfer"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Withdraw"): EventFragment;
}

export interface ApprovalEventObject {
  owner: string;
  spender: string;
  amount: BigNumber;
}
export type ApprovalEvent = TypedEvent<
  [string, string, BigNumber],
  ApprovalEventObject
>;

export type ApprovalEventFilter = TypedEventFilter<ApprovalEvent>;

export interface DepositEventObject {
  caller: string;
  to: string;
  assets: BigNumber;
  shares: BigNumber;
}
export type DepositEvent = TypedEvent<
  [string, string, BigNumber, BigNumber],
  DepositEventObject
>;

export type DepositEventFilter = TypedEventFilter<DepositEvent>;

export interface ExternalSwapEventObject {
  tokenId: BigNumber;
  amounts: BigNumber[];
  lpTokens: BigNumber;
  liquidity: BigNumber;
  txType: number;
}
export type ExternalSwapEvent = TypedEvent<
  [BigNumber, BigNumber[], BigNumber, BigNumber, number],
  ExternalSwapEventObject
>;

export type ExternalSwapEventFilter = TypedEventFilter<ExternalSwapEvent>;

export interface LiquidationEventObject {
  tokenId: BigNumber;
  collateral: BigNumber;
  liquidity: BigNumber;
  writeDownAmt: BigNumber;
  fee: BigNumber;
  txType: number;
}
export type LiquidationEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, BigNumber, BigNumber, number],
  LiquidationEventObject
>;

export type LiquidationEventFilter = TypedEventFilter<LiquidationEvent>;

export interface LoanCreatedEventObject {
  caller: string;
  tokenId: BigNumber;
  refId: number;
}
export type LoanCreatedEvent = TypedEvent<
  [string, BigNumber, number],
  LoanCreatedEventObject
>;

export type LoanCreatedEventFilter = TypedEventFilter<LoanCreatedEvent>;

export interface LoanUpdatedEventObject {
  tokenId: BigNumber;
  tokensHeld: BigNumber[];
  liquidity: BigNumber;
  initLiquidity: BigNumber;
  lpTokens: BigNumber;
  rateIndex: BigNumber;
  txType: number;
}
export type LoanUpdatedEvent = TypedEvent<
  [BigNumber, BigNumber[], BigNumber, BigNumber, BigNumber, BigNumber, number],
  LoanUpdatedEventObject
>;

export type LoanUpdatedEventFilter = TypedEventFilter<LoanUpdatedEvent>;

export interface PoolUpdatedEventObject {
  lpTokenBalance: BigNumber;
  lpTokenBorrowed: BigNumber;
  lastBlockNumber: number;
  accFeeIndex: BigNumber;
  lpTokenBorrowedPlusInterest: BigNumber;
  lpInvariant: BigNumber;
  borrowedInvariant: BigNumber;
  cfmmReserves: BigNumber[];
  txType: number;
}
export type PoolUpdatedEvent = TypedEvent<
  [
    BigNumber,
    BigNumber,
    number,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber[],
    number
  ],
  PoolUpdatedEventObject
>;

export type PoolUpdatedEventFilter = TypedEventFilter<PoolUpdatedEvent>;

export interface TransferEventObject {
  from: string;
  to: string;
  amount: BigNumber;
}
export type TransferEvent = TypedEvent<
  [string, string, BigNumber],
  TransferEventObject
>;

export type TransferEventFilter = TypedEventFilter<TransferEvent>;

export interface WithdrawEventObject {
  caller: string;
  to: string;
  from: string;
  assets: BigNumber;
  shares: BigNumber;
}
export type WithdrawEvent = TypedEvent<
  [string, string, string, BigNumber, BigNumber],
  WithdrawEventObject
>;

export type WithdrawEventFilter = TypedEventFilter<WithdrawEvent>;

export interface IGammaPool extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IGammaPoolInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    batchLiquidationStrategy(overrides?: CallOverrides): Promise<[string]>;

    batchLiquidations(
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    borrowLiquidity(
      tokenId: PromiseOrValue<BigNumberish>,
      lpTokens: PromiseOrValue<BigNumberish>,
      ratio: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    borrowStrategy(overrides?: CallOverrides): Promise<[string]>;

    calcInvariant(
      tokensHeld: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    cfmm(overrides?: CallOverrides): Promise<[string]>;

    createLoan(
      refId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    decreaseCollateral(
      tokenId: PromiseOrValue<BigNumberish>,
      amounts: PromiseOrValue<BigNumberish>[],
      to: PromiseOrValue<string>,
      ratio: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    depositNoPull(
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    depositReserves(
      to: PromiseOrValue<string>,
      amountsDesired: PromiseOrValue<BigNumberish>[],
      amountsMin: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    factory(overrides?: CallOverrides): Promise<[string]>;

    getCFMMBalances(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber, BigNumber] & {
        cfmmReserves: BigNumber[];
        cfmmInvariant: BigNumber;
        cfmmTotalSupply: BigNumber;
      }
    >;

    getFeeIndexUpdateParams(
      overrides?: CallOverrides
    ): Promise<
      [IGammaPool.FeeIndexUpdateParamsStructOutput] & {
        data: IGammaPool.FeeIndexUpdateParamsStructOutput;
      }
    >;

    getLastCFMMPrice(overrides?: CallOverrides): Promise<[BigNumber]>;

    getLatestCFMMBalances(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber, BigNumber] & {
        cfmmReserves: BigNumber[];
        cfmmInvariant: BigNumber;
        cfmmTotalSupply: BigNumber;
      }
    >;

    getLatestCFMMReserves(
      overrides?: CallOverrides
    ): Promise<[BigNumber[]] & { cfmmReserves: BigNumber[] }>;

    getLoanCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    getLoanData(
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [IGammaPool.LoanDataStructOutput] & {
        _loanData: IGammaPool.LoanDataStructOutput;
      }
    >;

    getLoans(
      start: PromiseOrValue<BigNumberish>,
      end: PromiseOrValue<BigNumberish>,
      active: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<
      [IGammaPool.LoanDataStructOutput[]] & {
        _loans: IGammaPool.LoanDataStructOutput[];
      }
    >;

    getLoansById(
      tokenIds: PromiseOrValue<BigNumberish>[],
      active: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<
      [IGammaPool.LoanDataStructOutput[]] & {
        _loans: IGammaPool.LoanDataStructOutput[];
      }
    >;

    getPoolBalances(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        tokenBalances: BigNumber[];
        lpTokenBalance: BigNumber;
        lpTokenBorrowed: BigNumber;
        lpTokenBorrowedPlusInterest: BigNumber;
        borrowedInvariant: BigNumber;
        lpInvariant: BigNumber;
      }
    >;

    getPoolData(
      overrides?: CallOverrides
    ): Promise<
      [IGammaPool.PoolDataStructOutput] & {
        data: IGammaPool.PoolDataStructOutput;
      }
    >;

    getRates(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        accFeeIndex: BigNumber;
        lastCFMMFeeIndex: BigNumber;
        lastBlockNumber: BigNumber;
      }
    >;

    increaseCollateral(
      tokenId: PromiseOrValue<BigNumberish>,
      ratio: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    initialize(
      _cfmm: PromiseOrValue<string>,
      _tokens: PromiseOrValue<string>[],
      _decimals: PromiseOrValue<BigNumberish>[],
      _data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    liquidate(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    liquidateWithLP(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    loan(
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [IGammaPool.LoanDataStructOutput] & {
        _loanData: IGammaPool.LoanDataStructOutput;
      }
    >;

    protocolId(overrides?: CallOverrides): Promise<[number]>;

    rateParamsStore(overrides?: CallOverrides): Promise<[string]>;

    rebalanceCollateral(
      tokenId: PromiseOrValue<BigNumberish>,
      deltas: PromiseOrValue<BigNumberish>[],
      ratio: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    rebalanceStrategy(overrides?: CallOverrides): Promise<[string]>;

    repayLiquidity(
      tokenId: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      collateralId: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    repayLiquiditySetRatio(
      tokenId: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      ratio: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    repayLiquidityWithLP(
      tokenId: PromiseOrValue<BigNumberish>,
      collateralId: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    repayStrategy(overrides?: CallOverrides): Promise<[string]>;

    setPoolParams(
      origFee: PromiseOrValue<BigNumberish>,
      extSwapFee: PromiseOrValue<BigNumberish>,
      emaMultiplier: PromiseOrValue<BigNumberish>,
      minUtilRate1: PromiseOrValue<BigNumberish>,
      minUtilRate2: PromiseOrValue<BigNumberish>,
      feeDivisor: PromiseOrValue<BigNumberish>,
      liquidationFee: PromiseOrValue<BigNumberish>,
      ltvThreshold: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    shortStrategy(overrides?: CallOverrides): Promise<[string]>;

    singleLiquidationStrategy(overrides?: CallOverrides): Promise<[string]>;

    skim(
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    sync(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    tokens(overrides?: CallOverrides): Promise<[string[]]>;

    updatePool(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    validateCFMM(
      _tokens: PromiseOrValue<string>[],
      _cfmm: PromiseOrValue<string>,
      _data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string[]] & { _tokensOrdered: string[] }>;

    validateParameters(
      _data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    viewer(overrides?: CallOverrides): Promise<[string]>;

    withdrawNoPull(
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawReserves(
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  batchLiquidationStrategy(overrides?: CallOverrides): Promise<string>;

  batchLiquidations(
    tokenIds: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  borrowLiquidity(
    tokenId: PromiseOrValue<BigNumberish>,
    lpTokens: PromiseOrValue<BigNumberish>,
    ratio: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  borrowStrategy(overrides?: CallOverrides): Promise<string>;

  calcInvariant(
    tokensHeld: PromiseOrValue<BigNumberish>[],
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  cfmm(overrides?: CallOverrides): Promise<string>;

  createLoan(
    refId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  decreaseCollateral(
    tokenId: PromiseOrValue<BigNumberish>,
    amounts: PromiseOrValue<BigNumberish>[],
    to: PromiseOrValue<string>,
    ratio: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  depositNoPull(
    to: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  depositReserves(
    to: PromiseOrValue<string>,
    amountsDesired: PromiseOrValue<BigNumberish>[],
    amountsMin: PromiseOrValue<BigNumberish>[],
    data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  factory(overrides?: CallOverrides): Promise<string>;

  getCFMMBalances(
    overrides?: CallOverrides
  ): Promise<
    [BigNumber[], BigNumber, BigNumber] & {
      cfmmReserves: BigNumber[];
      cfmmInvariant: BigNumber;
      cfmmTotalSupply: BigNumber;
    }
  >;

  getFeeIndexUpdateParams(
    overrides?: CallOverrides
  ): Promise<IGammaPool.FeeIndexUpdateParamsStructOutput>;

  getLastCFMMPrice(overrides?: CallOverrides): Promise<BigNumber>;

  getLatestCFMMBalances(
    overrides?: CallOverrides
  ): Promise<
    [BigNumber[], BigNumber, BigNumber] & {
      cfmmReserves: BigNumber[];
      cfmmInvariant: BigNumber;
      cfmmTotalSupply: BigNumber;
    }
  >;

  getLatestCFMMReserves(overrides?: CallOverrides): Promise<BigNumber[]>;

  getLoanCount(overrides?: CallOverrides): Promise<BigNumber>;

  getLoanData(
    _tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<IGammaPool.LoanDataStructOutput>;

  getLoans(
    start: PromiseOrValue<BigNumberish>,
    end: PromiseOrValue<BigNumberish>,
    active: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<IGammaPool.LoanDataStructOutput[]>;

  getLoansById(
    tokenIds: PromiseOrValue<BigNumberish>[],
    active: PromiseOrValue<boolean>,
    overrides?: CallOverrides
  ): Promise<IGammaPool.LoanDataStructOutput[]>;

  getPoolBalances(
    overrides?: CallOverrides
  ): Promise<
    [BigNumber[], BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
      tokenBalances: BigNumber[];
      lpTokenBalance: BigNumber;
      lpTokenBorrowed: BigNumber;
      lpTokenBorrowedPlusInterest: BigNumber;
      borrowedInvariant: BigNumber;
      lpInvariant: BigNumber;
    }
  >;

  getPoolData(
    overrides?: CallOverrides
  ): Promise<IGammaPool.PoolDataStructOutput>;

  getRates(
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber] & {
      accFeeIndex: BigNumber;
      lastCFMMFeeIndex: BigNumber;
      lastBlockNumber: BigNumber;
    }
  >;

  increaseCollateral(
    tokenId: PromiseOrValue<BigNumberish>,
    ratio: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  initialize(
    _cfmm: PromiseOrValue<string>,
    _tokens: PromiseOrValue<string>[],
    _decimals: PromiseOrValue<BigNumberish>[],
    _data: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  liquidate(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  liquidateWithLP(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  loan(
    _tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<IGammaPool.LoanDataStructOutput>;

  protocolId(overrides?: CallOverrides): Promise<number>;

  rateParamsStore(overrides?: CallOverrides): Promise<string>;

  rebalanceCollateral(
    tokenId: PromiseOrValue<BigNumberish>,
    deltas: PromiseOrValue<BigNumberish>[],
    ratio: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  rebalanceStrategy(overrides?: CallOverrides): Promise<string>;

  repayLiquidity(
    tokenId: PromiseOrValue<BigNumberish>,
    liquidity: PromiseOrValue<BigNumberish>,
    collateralId: PromiseOrValue<BigNumberish>,
    to: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  repayLiquiditySetRatio(
    tokenId: PromiseOrValue<BigNumberish>,
    liquidity: PromiseOrValue<BigNumberish>,
    ratio: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  repayLiquidityWithLP(
    tokenId: PromiseOrValue<BigNumberish>,
    collateralId: PromiseOrValue<BigNumberish>,
    to: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  repayStrategy(overrides?: CallOverrides): Promise<string>;

  setPoolParams(
    origFee: PromiseOrValue<BigNumberish>,
    extSwapFee: PromiseOrValue<BigNumberish>,
    emaMultiplier: PromiseOrValue<BigNumberish>,
    minUtilRate1: PromiseOrValue<BigNumberish>,
    minUtilRate2: PromiseOrValue<BigNumberish>,
    feeDivisor: PromiseOrValue<BigNumberish>,
    liquidationFee: PromiseOrValue<BigNumberish>,
    ltvThreshold: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  shortStrategy(overrides?: CallOverrides): Promise<string>;

  singleLiquidationStrategy(overrides?: CallOverrides): Promise<string>;

  skim(
    to: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  sync(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  tokens(overrides?: CallOverrides): Promise<string[]>;

  updatePool(
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  validateCFMM(
    _tokens: PromiseOrValue<string>[],
    _cfmm: PromiseOrValue<string>,
    _data: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string[]>;

  validateParameters(
    _data: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  viewer(overrides?: CallOverrides): Promise<string>;

  withdrawNoPull(
    to: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawReserves(
    to: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    batchLiquidationStrategy(overrides?: CallOverrides): Promise<string>;

    batchLiquidations(
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber[]] & {
        totalLoanLiquidity: BigNumber;
        refund: BigNumber[];
      }
    >;

    borrowLiquidity(
      tokenId: PromiseOrValue<BigNumberish>,
      lpTokens: PromiseOrValue<BigNumberish>,
      ratio: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber[]] & {
        liquidityBorrowed: BigNumber;
        amounts: BigNumber[];
      }
    >;

    borrowStrategy(overrides?: CallOverrides): Promise<string>;

    calcInvariant(
      tokensHeld: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    cfmm(overrides?: CallOverrides): Promise<string>;

    createLoan(
      refId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    decreaseCollateral(
      tokenId: PromiseOrValue<BigNumberish>,
      amounts: PromiseOrValue<BigNumberish>[],
      to: PromiseOrValue<string>,
      ratio: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    depositNoPull(
      to: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    depositReserves(
      to: PromiseOrValue<string>,
      amountsDesired: PromiseOrValue<BigNumberish>[],
      amountsMin: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber] & { reserves: BigNumber[]; shares: BigNumber }
    >;

    factory(overrides?: CallOverrides): Promise<string>;

    getCFMMBalances(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber, BigNumber] & {
        cfmmReserves: BigNumber[];
        cfmmInvariant: BigNumber;
        cfmmTotalSupply: BigNumber;
      }
    >;

    getFeeIndexUpdateParams(
      overrides?: CallOverrides
    ): Promise<IGammaPool.FeeIndexUpdateParamsStructOutput>;

    getLastCFMMPrice(overrides?: CallOverrides): Promise<BigNumber>;

    getLatestCFMMBalances(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber, BigNumber] & {
        cfmmReserves: BigNumber[];
        cfmmInvariant: BigNumber;
        cfmmTotalSupply: BigNumber;
      }
    >;

    getLatestCFMMReserves(overrides?: CallOverrides): Promise<BigNumber[]>;

    getLoanCount(overrides?: CallOverrides): Promise<BigNumber>;

    getLoanData(
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<IGammaPool.LoanDataStructOutput>;

    getLoans(
      start: PromiseOrValue<BigNumberish>,
      end: PromiseOrValue<BigNumberish>,
      active: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<IGammaPool.LoanDataStructOutput[]>;

    getLoansById(
      tokenIds: PromiseOrValue<BigNumberish>[],
      active: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<IGammaPool.LoanDataStructOutput[]>;

    getPoolBalances(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber, BigNumber, BigNumber, BigNumber, BigNumber] & {
        tokenBalances: BigNumber[];
        lpTokenBalance: BigNumber;
        lpTokenBorrowed: BigNumber;
        lpTokenBorrowedPlusInterest: BigNumber;
        borrowedInvariant: BigNumber;
        lpInvariant: BigNumber;
      }
    >;

    getPoolData(
      overrides?: CallOverrides
    ): Promise<IGammaPool.PoolDataStructOutput>;

    getRates(
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber] & {
        accFeeIndex: BigNumber;
        lastCFMMFeeIndex: BigNumber;
        lastBlockNumber: BigNumber;
      }
    >;

    increaseCollateral(
      tokenId: PromiseOrValue<BigNumberish>,
      ratio: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    initialize(
      _cfmm: PromiseOrValue<string>,
      _tokens: PromiseOrValue<string>[],
      _decimals: PromiseOrValue<BigNumberish>[],
      _data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    liquidate(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & { loanLiquidity: BigNumber; refund: BigNumber }
    >;

    liquidateWithLP(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber[]] & {
        loanLiquidity: BigNumber;
        refund: BigNumber[];
      }
    >;

    loan(
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<IGammaPool.LoanDataStructOutput>;

    protocolId(overrides?: CallOverrides): Promise<number>;

    rateParamsStore(overrides?: CallOverrides): Promise<string>;

    rebalanceCollateral(
      tokenId: PromiseOrValue<BigNumberish>,
      deltas: PromiseOrValue<BigNumberish>[],
      ratio: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    rebalanceStrategy(overrides?: CallOverrides): Promise<string>;

    repayLiquidity(
      tokenId: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      collateralId: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber[]] & {
        liquidityPaid: BigNumber;
        amounts: BigNumber[];
      }
    >;

    repayLiquiditySetRatio(
      tokenId: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      ratio: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber[]] & {
        liquidityPaid: BigNumber;
        amounts: BigNumber[];
      }
    >;

    repayLiquidityWithLP(
      tokenId: PromiseOrValue<BigNumberish>,
      collateralId: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber[]] & {
        liquidityPaid: BigNumber;
        tokensHeld: BigNumber[];
      }
    >;

    repayStrategy(overrides?: CallOverrides): Promise<string>;

    setPoolParams(
      origFee: PromiseOrValue<BigNumberish>,
      extSwapFee: PromiseOrValue<BigNumberish>,
      emaMultiplier: PromiseOrValue<BigNumberish>,
      minUtilRate1: PromiseOrValue<BigNumberish>,
      minUtilRate2: PromiseOrValue<BigNumberish>,
      feeDivisor: PromiseOrValue<BigNumberish>,
      liquidationFee: PromiseOrValue<BigNumberish>,
      ltvThreshold: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    shortStrategy(overrides?: CallOverrides): Promise<string>;

    singleLiquidationStrategy(overrides?: CallOverrides): Promise<string>;

    skim(to: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;

    sync(overrides?: CallOverrides): Promise<void>;

    tokens(overrides?: CallOverrides): Promise<string[]>;

    updatePool(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        loanLiquidityDebt: BigNumber;
        poolLiquidityDebt: BigNumber;
      }
    >;

    validateCFMM(
      _tokens: PromiseOrValue<string>[],
      _cfmm: PromiseOrValue<string>,
      _data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string[]>;

    validateParameters(
      _data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    viewer(overrides?: CallOverrides): Promise<string>;

    withdrawNoPull(
      to: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    withdrawReserves(
      to: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], BigNumber] & { reserves: BigNumber[]; assets: BigNumber }
    >;
  };

  filters: {
    "Approval(address,address,uint256)"(
      owner?: PromiseOrValue<string> | null,
      spender?: PromiseOrValue<string> | null,
      amount?: null
    ): ApprovalEventFilter;
    Approval(
      owner?: PromiseOrValue<string> | null,
      spender?: PromiseOrValue<string> | null,
      amount?: null
    ): ApprovalEventFilter;

    "Deposit(address,address,uint256,uint256)"(
      caller?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      assets?: null,
      shares?: null
    ): DepositEventFilter;
    Deposit(
      caller?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      assets?: null,
      shares?: null
    ): DepositEventFilter;

    "ExternalSwap(uint256,uint128[],uint256,uint128,uint8)"(
      tokenId?: PromiseOrValue<BigNumberish> | null,
      amounts?: null,
      lpTokens?: null,
      liquidity?: null,
      txType?: PromiseOrValue<BigNumberish> | null
    ): ExternalSwapEventFilter;
    ExternalSwap(
      tokenId?: PromiseOrValue<BigNumberish> | null,
      amounts?: null,
      lpTokens?: null,
      liquidity?: null,
      txType?: PromiseOrValue<BigNumberish> | null
    ): ExternalSwapEventFilter;

    "Liquidation(uint256,uint128,uint128,uint128,uint128,uint8)"(
      tokenId?: PromiseOrValue<BigNumberish> | null,
      collateral?: null,
      liquidity?: null,
      writeDownAmt?: null,
      fee?: null,
      txType?: null
    ): LiquidationEventFilter;
    Liquidation(
      tokenId?: PromiseOrValue<BigNumberish> | null,
      collateral?: null,
      liquidity?: null,
      writeDownAmt?: null,
      fee?: null,
      txType?: null
    ): LiquidationEventFilter;

    "LoanCreated(address,uint256,uint16)"(
      caller?: PromiseOrValue<string> | null,
      tokenId?: null,
      refId?: null
    ): LoanCreatedEventFilter;
    LoanCreated(
      caller?: PromiseOrValue<string> | null,
      tokenId?: null,
      refId?: null
    ): LoanCreatedEventFilter;

    "LoanUpdated(uint256,uint128[],uint128,uint128,uint256,uint96,uint8)"(
      tokenId?: PromiseOrValue<BigNumberish> | null,
      tokensHeld?: null,
      liquidity?: null,
      initLiquidity?: null,
      lpTokens?: null,
      rateIndex?: null,
      txType?: PromiseOrValue<BigNumberish> | null
    ): LoanUpdatedEventFilter;
    LoanUpdated(
      tokenId?: PromiseOrValue<BigNumberish> | null,
      tokensHeld?: null,
      liquidity?: null,
      initLiquidity?: null,
      lpTokens?: null,
      rateIndex?: null,
      txType?: PromiseOrValue<BigNumberish> | null
    ): LoanUpdatedEventFilter;

    "PoolUpdated(uint256,uint256,uint40,uint80,uint256,uint128,uint128,uint128[],uint8)"(
      lpTokenBalance?: null,
      lpTokenBorrowed?: null,
      lastBlockNumber?: null,
      accFeeIndex?: null,
      lpTokenBorrowedPlusInterest?: null,
      lpInvariant?: null,
      borrowedInvariant?: null,
      cfmmReserves?: null,
      txType?: PromiseOrValue<BigNumberish> | null
    ): PoolUpdatedEventFilter;
    PoolUpdated(
      lpTokenBalance?: null,
      lpTokenBorrowed?: null,
      lastBlockNumber?: null,
      accFeeIndex?: null,
      lpTokenBorrowedPlusInterest?: null,
      lpInvariant?: null,
      borrowedInvariant?: null,
      cfmmReserves?: null,
      txType?: PromiseOrValue<BigNumberish> | null
    ): PoolUpdatedEventFilter;

    "Transfer(address,address,uint256)"(
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      amount?: null
    ): TransferEventFilter;
    Transfer(
      from?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      amount?: null
    ): TransferEventFilter;

    "Withdraw(address,address,address,uint256,uint256)"(
      caller?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      assets?: null,
      shares?: null
    ): WithdrawEventFilter;
    Withdraw(
      caller?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      from?: PromiseOrValue<string> | null,
      assets?: null,
      shares?: null
    ): WithdrawEventFilter;
  };

  estimateGas: {
    batchLiquidationStrategy(overrides?: CallOverrides): Promise<BigNumber>;

    batchLiquidations(
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    borrowLiquidity(
      tokenId: PromiseOrValue<BigNumberish>,
      lpTokens: PromiseOrValue<BigNumberish>,
      ratio: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    borrowStrategy(overrides?: CallOverrides): Promise<BigNumber>;

    calcInvariant(
      tokensHeld: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    cfmm(overrides?: CallOverrides): Promise<BigNumber>;

    createLoan(
      refId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    decreaseCollateral(
      tokenId: PromiseOrValue<BigNumberish>,
      amounts: PromiseOrValue<BigNumberish>[],
      to: PromiseOrValue<string>,
      ratio: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    depositNoPull(
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    depositReserves(
      to: PromiseOrValue<string>,
      amountsDesired: PromiseOrValue<BigNumberish>[],
      amountsMin: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    factory(overrides?: CallOverrides): Promise<BigNumber>;

    getCFMMBalances(overrides?: CallOverrides): Promise<BigNumber>;

    getFeeIndexUpdateParams(overrides?: CallOverrides): Promise<BigNumber>;

    getLastCFMMPrice(overrides?: CallOverrides): Promise<BigNumber>;

    getLatestCFMMBalances(overrides?: CallOverrides): Promise<BigNumber>;

    getLatestCFMMReserves(overrides?: CallOverrides): Promise<BigNumber>;

    getLoanCount(overrides?: CallOverrides): Promise<BigNumber>;

    getLoanData(
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLoans(
      start: PromiseOrValue<BigNumberish>,
      end: PromiseOrValue<BigNumberish>,
      active: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getLoansById(
      tokenIds: PromiseOrValue<BigNumberish>[],
      active: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getPoolBalances(overrides?: CallOverrides): Promise<BigNumber>;

    getPoolData(overrides?: CallOverrides): Promise<BigNumber>;

    getRates(overrides?: CallOverrides): Promise<BigNumber>;

    increaseCollateral(
      tokenId: PromiseOrValue<BigNumberish>,
      ratio: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    initialize(
      _cfmm: PromiseOrValue<string>,
      _tokens: PromiseOrValue<string>[],
      _decimals: PromiseOrValue<BigNumberish>[],
      _data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    liquidate(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    liquidateWithLP(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    loan(
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    protocolId(overrides?: CallOverrides): Promise<BigNumber>;

    rateParamsStore(overrides?: CallOverrides): Promise<BigNumber>;

    rebalanceCollateral(
      tokenId: PromiseOrValue<BigNumberish>,
      deltas: PromiseOrValue<BigNumberish>[],
      ratio: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    rebalanceStrategy(overrides?: CallOverrides): Promise<BigNumber>;

    repayLiquidity(
      tokenId: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      collateralId: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    repayLiquiditySetRatio(
      tokenId: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      ratio: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    repayLiquidityWithLP(
      tokenId: PromiseOrValue<BigNumberish>,
      collateralId: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    repayStrategy(overrides?: CallOverrides): Promise<BigNumber>;

    setPoolParams(
      origFee: PromiseOrValue<BigNumberish>,
      extSwapFee: PromiseOrValue<BigNumberish>,
      emaMultiplier: PromiseOrValue<BigNumberish>,
      minUtilRate1: PromiseOrValue<BigNumberish>,
      minUtilRate2: PromiseOrValue<BigNumberish>,
      feeDivisor: PromiseOrValue<BigNumberish>,
      liquidationFee: PromiseOrValue<BigNumberish>,
      ltvThreshold: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    shortStrategy(overrides?: CallOverrides): Promise<BigNumber>;

    singleLiquidationStrategy(overrides?: CallOverrides): Promise<BigNumber>;

    skim(
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    sync(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    tokens(overrides?: CallOverrides): Promise<BigNumber>;

    updatePool(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    validateCFMM(
      _tokens: PromiseOrValue<string>[],
      _cfmm: PromiseOrValue<string>,
      _data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    validateParameters(
      _data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    viewer(overrides?: CallOverrides): Promise<BigNumber>;

    withdrawNoPull(
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawReserves(
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    batchLiquidationStrategy(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    batchLiquidations(
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    borrowLiquidity(
      tokenId: PromiseOrValue<BigNumberish>,
      lpTokens: PromiseOrValue<BigNumberish>,
      ratio: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    borrowStrategy(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    calcInvariant(
      tokensHeld: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    cfmm(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    createLoan(
      refId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    decreaseCollateral(
      tokenId: PromiseOrValue<BigNumberish>,
      amounts: PromiseOrValue<BigNumberish>[],
      to: PromiseOrValue<string>,
      ratio: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    depositNoPull(
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    depositReserves(
      to: PromiseOrValue<string>,
      amountsDesired: PromiseOrValue<BigNumberish>[],
      amountsMin: PromiseOrValue<BigNumberish>[],
      data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    factory(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getCFMMBalances(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getFeeIndexUpdateParams(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLastCFMMPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getLatestCFMMBalances(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLatestCFMMReserves(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLoanCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getLoanData(
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLoans(
      start: PromiseOrValue<BigNumberish>,
      end: PromiseOrValue<BigNumberish>,
      active: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getLoansById(
      tokenIds: PromiseOrValue<BigNumberish>[],
      active: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getPoolBalances(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getPoolData(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getRates(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    increaseCollateral(
      tokenId: PromiseOrValue<BigNumberish>,
      ratio: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    initialize(
      _cfmm: PromiseOrValue<string>,
      _tokens: PromiseOrValue<string>[],
      _decimals: PromiseOrValue<BigNumberish>[],
      _data: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    liquidate(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    liquidateWithLP(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    loan(
      _tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    protocolId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rateParamsStore(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    rebalanceCollateral(
      tokenId: PromiseOrValue<BigNumberish>,
      deltas: PromiseOrValue<BigNumberish>[],
      ratio: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    rebalanceStrategy(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    repayLiquidity(
      tokenId: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      collateralId: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    repayLiquiditySetRatio(
      tokenId: PromiseOrValue<BigNumberish>,
      liquidity: PromiseOrValue<BigNumberish>,
      ratio: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    repayLiquidityWithLP(
      tokenId: PromiseOrValue<BigNumberish>,
      collateralId: PromiseOrValue<BigNumberish>,
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    repayStrategy(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setPoolParams(
      origFee: PromiseOrValue<BigNumberish>,
      extSwapFee: PromiseOrValue<BigNumberish>,
      emaMultiplier: PromiseOrValue<BigNumberish>,
      minUtilRate1: PromiseOrValue<BigNumberish>,
      minUtilRate2: PromiseOrValue<BigNumberish>,
      feeDivisor: PromiseOrValue<BigNumberish>,
      liquidationFee: PromiseOrValue<BigNumberish>,
      ltvThreshold: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    shortStrategy(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    singleLiquidationStrategy(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    skim(
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    sync(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    tokens(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    updatePool(
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    validateCFMM(
      _tokens: PromiseOrValue<string>[],
      _cfmm: PromiseOrValue<string>,
      _data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    validateParameters(
      _data: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    viewer(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    withdrawNoPull(
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawReserves(
      to: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
